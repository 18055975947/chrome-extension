import{_ as s,c as e,o as a,a4 as i}from"./chunks/framework.DUbQYUwk.js";const u=JSON.parse('{"title":"Service Worker","description":"","frontmatter":{},"headers":[],"relativePath":"core/service-worker.md","filePath":"core/service-worker.md"}'),n={name:"core/service-worker.md"},r=i('<h1 id="service-worker" tabindex="-1"><code>Service Worker</code> <a class="header-anchor" href="#service-worker" aria-label="Permalink to &quot;`Service Worker`&quot;">​</a></h1><p>插件 <code>Service Worker</code> 是插件的核心事件处理脚本。这使得它们与 <code>Web Service Worker</code> 明显不同</p><p><code>Extension Service Worker</code> 与 <code>Web Service Worker</code> 有一些共同点。 <code>Service Worker</code> 在需要时加载，并在其进入休眠状态时取消加载。只要插件 <code>Service Worker</code> 在加载后还会主动接收事件，它就会运行，不过它可以关闭。与对应的 <code>Web</code> 应用一样， <code>Service Worker</code> 无法访问 <code>DOM</code>，不过可以根据需要将其用于 <code>offscreen</code>。</p><p>插件 <code>Service Worker</code> 不只是网络代理（因为经常会提到 <code>Web Service Worker</code>）。除了标准 <code>Service Worker</code> 事件之外，它们还会响应插件事件，例如导航到新页面、点击通知或关闭标签页。它们的注册和更新方式也与 <code>Web Service Worker</code> 不同。</p><h2 id="一、注册-service-worker" tabindex="-1">一、注册 <code>Service Worker</code> <a class="header-anchor" href="#一、注册-service-worker" aria-label="Permalink to &quot;一、注册 `Service Worker`&quot;">​</a></h2><p>要注册 <code>Service Worker</code>，先在 <code>manifest.json</code> 文件的 <code>&quot;background&quot;</code> 字段中指定它。使用 <code>&quot;service_worker&quot;</code> 字段，该字段会指定单个 <code>JavaScript</code> 文件。</p><div class="language-josn vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">josn</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{</span></span>\n<span class="line"><span>  &quot;name&quot;: &quot;Awesome Test Extension&quot;,</span></span>\n<span class="line"><span>  &quot;background&quot;: {</span></span>\n<span class="line"><span>    &quot;service_worker&quot;: &quot;service-worker.js&quot;</span></span>\n<span class="line"><span>  },</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="二、导入脚本" tabindex="-1">二、导入脚本 <a class="header-anchor" href="#二、导入脚本" aria-label="Permalink to &quot;二、导入脚本&quot;">​</a></h2><p>将脚本导入 <code>Service Worker</code> 的方法有两种：<code>import</code> 语句和 <code>importScripts()</code> 方法。</p><p>如需使用 <code>import</code> 语句，请将 <code>&quot;type&quot;</code> 字段添加到 <code>manifest.json</code> 文件中并指定 <code>&quot;module&quot;</code>。</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;background&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;service_worker&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;service-worker.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后，像往常一样使用 <code>import</code>。请注意，不支持导入断言。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { tldLocales } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./locales.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>像在 <code>Web Service Worker</code> 中一样使用 <code>importScripts()</code>。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">importScripts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;locales.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="_1-1-导入多个-service-worker-模块" tabindex="-1">1.1. 导入多个 <code>Service Worker</code> 模块 <a class="header-anchor" href="#_1-1-导入多个-service-worker-模块" aria-label="Permalink to &quot;1.1. 导入多个 `Service Worker` 模块&quot;">​</a></h4><p>我们的 <code>Service Worker</code> 实现了两项功能。为了提高可维护性，我们将在单独的模块中实现每项功能。首先，我们需要在 <code>manifest.json</code> 文件中将 <code>Service Worker</code> 声明为一个 <a href="https://web.dev/es-modules-in-sw/?hlen" target="_blank" rel="noreferrer"><code>ES module</code></a>，这样我们就可以将模块导入到 <code>Service Worker</code> 中：</p><ol><li><code>manifest.json</code>:</li></ol><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;background&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;service_worker&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;service-worker.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li>创建 <code>service-worker.js</code> 文件并导入两个模块：</li></ol><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./sw-omnibox.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./sw-tips.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="3"><li>创建这些文件并为每个文件添加控制台日志。</li></ol><ul><li>sw-omnibox.js:</li></ul><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sw-omnibox.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>sw-tips.js:</li></ul><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sw-tips.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="三、更新" tabindex="-1">三、更新 <a class="header-anchor" href="#三、更新" aria-label="Permalink to &quot;三、更新&quot;">​</a></h2><p>要更新 <code>Service Worker</code>，向 <code>Chrome</code> 应用商店发布新版本的插件。无法通过从服务器加载插件来解决此问题。出于安全原因，<code>Manifest V3</code> 不支持远程托管的代码。</p><p><strong><code>Service Worker</code> 必须是插件软件包的一部分。</strong></p><h2 id="四、service-worker-事件" tabindex="-1">四、<code>Service Worker</code> 事件 <a class="header-anchor" href="#四、service-worker-事件" aria-label="Permalink to &quot;四、`Service Worker` 事件&quot;">​</a></h2><p>插件 <code>Service Worker</code> 同时支持标准 <code>Service Worker</code> 事件和插件 <code>API</code> 中的许多事件。</p><h3 id="_1-声明插件事件" tabindex="-1">1. 声明插件事件 <a class="header-anchor" href="#_1-声明插件事件" aria-label="Permalink to &quot;1. 声明插件事件&quot;">​</a></h3><p><code>Service Worker</code> 中的事件处理脚本需要在全局范围内声明，这意味着它们应该位于脚本的顶层，而不应嵌套在函数内。这样可以确保它们在脚本初始执行时同步注册，从而使 <code>Chrome</code> 能够在 <code>Service Worker</code> 启动后立即将事件分派给它。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chrome.action.onClicked.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(handleActionClick);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chrome.storage.local.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;badgeText&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">badgeText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  chrome.action.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setBadgeText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ text: badgeText });</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_2-常见事件" tabindex="-1">2. 常见事件 <a class="header-anchor" href="#_2-常见事件" aria-label="Permalink to &quot;2. 常见事件&quot;">​</a></h3><h4 id="_2-1-chrome-action" tabindex="-1">2.1. <code>chrome.action</code> <a class="header-anchor" href="#_2-1-chrome-action" aria-label="Permalink to &quot;2.1. `chrome.action`&quot;">​</a></h4><p>当有用户与插件的工具栏图标互动时触发，无论该操作是针对特定网页（标签页）还是整个插件。</p><h4 id="_2-2-chrome-management" tabindex="-1">2.2. <code>chrome.management</code> <a class="header-anchor" href="#_2-2-chrome-management" aria-label="Permalink to &quot;2.2. `chrome.management`&quot;">​</a></h4><p>提供与安装、卸载、启用和停用插件相关的事件。</p><h4 id="_2-3-chrome-notifications" tabindex="-1">2.3. <code>chrome.notifications</code> <a class="header-anchor" href="#_2-3-chrome-notifications" aria-label="Permalink to &quot;2.3. `chrome.notifications`&quot;">​</a></h4><p>提供与用户与插件生成的系统通知互动相关的事件。</p><h4 id="_2-4-chrome-permissions" tabindex="-1">2.4. <code>chrome.permissions</code> <a class="header-anchor" href="#_2-4-chrome-permissions" aria-label="Permalink to &quot;2.4. `chrome.permissions`&quot;">​</a></h4><p>指示用户何时授予或撤消插件权限。</p><h4 id="_2-5-chrome-runtime" tabindex="-1">2.5. <code>chrome.runtime</code> <a class="header-anchor" href="#_2-5-chrome-runtime" aria-label="Permalink to &quot;2.5. `chrome.runtime`&quot;">​</a></h4><p>提供与插件生命周期相关的事件、插件的其他部分发送的消息，以及可用插件或 Chrome 更新的通知。</p><h4 id="_2-6-chrome-storage-onchanged" tabindex="-1">2.6. <code>chrome.storage.onChanged</code> <a class="header-anchor" href="#_2-6-chrome-storage-onchanged" aria-label="Permalink to &quot;2.6. `chrome.storage.onChanged`&quot;">​</a></h4><p>每当任何 <code>StorageArea</code> 对象被清除或某个键的值被更改或设置时触发。请注意，每个 <code>StorageArea</code> 实例都有自己的 <code>onChanged</code> 事件。</p><h4 id="_2-7-chrome-webnavigation" tabindex="-1">2.7. <code>chrome.webNavigation</code> <a class="header-anchor" href="#_2-7-chrome-webnavigation" aria-label="Permalink to &quot;2.7. `chrome.webNavigation`&quot;">​</a></h4><p>提供有关飞行中导航请求状态的信息。</p><h3 id="_3-过滤-filter" tabindex="-1">3. 过滤 <code>Filter</code> <a class="header-anchor" href="#_3-过滤-filter" aria-label="Permalink to &quot;3. 过滤 `Filter`&quot;">​</a></h3><p>要将事件限制为特定用例，或消除不必要的事件调用，请使用支持事件过滤器的 <code>API</code>。例如，假设某个插件会监听 <code>tabs.onUpdated</code> 事件，以检测用户何时导航到特定网站。系统会在每个标签页上的每次导航时调用此事件。请改为搭配使用 <code>webNavigation.onCompleted</code> 和过滤条件。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> filter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  url: [</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      urlMatches: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://www.google.com/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chrome.webNavigation.onCompleted.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;The user has loaded my favorite website!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, filter);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="五、service-worker-生命周期" tabindex="-1">五、<code>Service Worker</code> 生命周期 <a class="header-anchor" href="#五、service-worker-生命周期" aria-label="Permalink to &quot;五、`Service Worker` 生命周期&quot;">​</a></h2><h3 id="_1-安装" tabindex="-1">1. 安装 <a class="header-anchor" href="#_1-安装" aria-label="Permalink to &quot;1. 安装&quot;">​</a></h3><p>当用户从 <code>Chrome</code> 应用商店安装或更新 <code>Service Worker</code>，或者用户使用 <code>chrome://extensions</code> 页面加载或更新已解压的插件时，就会发生安装。按以下顺序发生三个事件。</p><h4 id="_1-1-serviceworkerregistration-install" tabindex="-1">1.1. <code>ServiceWorkerRegistration.install</code> <a class="header-anchor" href="#_1-1-serviceworkerregistration-install" aria-label="Permalink to &quot;1.1. `ServiceWorkerRegistration.install`&quot;">​</a></h4><p>安装期间触发的第一个事件是 <code>Web Service Worker</code> 的 <code>install</code> 事件。</p><h4 id="_1-2-chrome-runtime-oninstalled" tabindex="-1">1.2. <code>chrome.runtime.onInstalled</code> <a class="header-anchor" href="#_1-2-chrome-runtime-oninstalled" aria-label="Permalink to &quot;1.2. `chrome.runtime.onInstalled`&quot;">​</a></h4><p>接下来是该插件的 <code>onInstalled</code> 事件，当该插件（而不是 <code>Service Worker</code>）首次安装时、该插件更新到新版本以及 <code>Chrome</code> 更新到新版本时，都会触发该事件。使用此事件来设置状态或一次性初始化，例如上下文菜单。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chrome.runtime.onInstalled.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">details</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(details.reason </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;install&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> details.reason </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;update&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  chrome.contextMenus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sampleContextMenu&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;title&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Sample Context Menu&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;contexts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;selection&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_1-3-serviceworkerregistration-active" tabindex="-1">1.3. <code>ServiceWorkerRegistration.active</code> <a class="header-anchor" href="#_1-3-serviceworkerregistration-active" aria-label="Permalink to &quot;1.3. `ServiceWorkerRegistration.active`&quot;">​</a></h4><p>最后，系统将触发 <code>Service Worker</code> 的 <code>activate</code> 事件。请注意，与 <code>Web Service Worker</code> 不同，此事件会在安装插件后立即触发，因为没有与插件中的页面重新加载相媲美的功能。</p><h3 id="_2-插件启动" tabindex="-1">2. 插件启动 <a class="header-anchor" href="#_2-插件启动" aria-label="Permalink to &quot;2. 插件启动&quot;">​</a></h3><p>当 <code>user profile</code> 启动时，会触发 <code>chrome.runtime.onStartup</code> 事件，但不会调用任何 <code>Service Worker</code> 事件。</p><h3 id="_3-闲置和关闭" tabindex="-1">3. 闲置和关闭 <a class="header-anchor" href="#_3-闲置和关闭" aria-label="Permalink to &quot;3. 闲置和关闭&quot;">​</a></h3><p>通常，<code>Chrome</code> 会在满足以下条件之一时终止 <code>Service Worker</code>：</p><ul><li>无操作 30 秒后。收到事件或调用插件 <code>API</code> 会重置此计时器。</li><li>单个请求（例如事件或 API 调用）的处理用时超过 5 分钟。</li><li>当 <code>fetch()</code> 响应的传递时间超过 30 秒时。</li></ul><p>事件和对插件 API 的调用会重置这些计时器，如果 <code>Service Worker</code> 已休眠，传入事件将使它们恢复。应该将 <code>Service Worker</code> 设计为能够灵活应对意外终止。</p><h3 id="_4-保存数据" tabindex="-1">4. 保存数据 <a class="header-anchor" href="#_4-保存数据" aria-label="Permalink to &quot;4. 保存数据&quot;">​</a></h3><p>如果 <code>Service Worker</code> 关闭，设置的任何全局变量都将丢失。将值保存到存储空间，而不是使用全局变量。请注意，<code>Web Storage API</code> 不适用于插件 <code>Service Worker</code>。</p><h4 id="_4-1-chrome-storage-api" tabindex="-1">4.1. <code>chrome.storage API</code> <a class="header-anchor" href="#_4-1-chrome-storage-api" aria-label="Permalink to &quot;4.1. `chrome.storage API`&quot;">​</a></h4><p>一种插件 <code>API</code>，提供多种存储类型；本地存储、会话存储、托管（网域）和同步存储。此 <code>API</code> 用于存储使用开发者定义的密钥识别和检索的 <code>JSON</code> 对象。当用户清除网页缓存时，此类存储空间不会移除。</p><h4 id="_4-2-indexeddb-api" tabindex="-1">4.2. <code>IndexedDB API</code> <a class="header-anchor" href="#_4-2-indexeddb-api" aria-label="Permalink to &quot;4.2. `IndexedDB API`&quot;">​</a></h4><p>用于在客户端存储结构化数据（包括文件和 <code>blob</code>）的低级别 <code>API</code>。此 <code>API</code> 提供了用于创建事务型数据存储和检索的原语。虽然此 <code>API</code> 通常对于简单的使用场景而言过于复杂，但在此基础上构建了许多第三方存储解决方案。</p><h4 id="_4-3-cachestorage-api" tabindex="-1">4.3. <code>CacheStorage API</code> <a class="header-anchor" href="#_4-3-cachestorage-api" aria-label="Permalink to &quot;4.3. `CacheStorage API`&quot;">​</a></h4><p>请求和响应对象对的永久性存储机制。此 API 专为 Web Service Worker 设计，用于从端点检索数据。可通过多种方式使用此 API，具体取决于用户是否查看最新数据及其重要性。有关详情，请参阅<a href="https://web.dev/articles/offline-cookbook?hlen" target="_blank" rel="noreferrer">离线指南</a>。除非专门通过提取处理程序来代理网络请求，否则应使用 chrome.storage。</p>',76),t=[r];function o(l,p,h,c,d,k){return a(),e("div",null,t)}const b=s(n,[["render",o]]);export{u as __pageData,b as default};
