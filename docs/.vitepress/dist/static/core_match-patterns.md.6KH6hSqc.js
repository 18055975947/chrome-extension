import{_ as e,c as o,o as a,a4 as l}from"./chunks/framework.DUbQYUwk.js";const g=JSON.parse('{"title":"匹配模式（Match patterns）","description":"","frontmatter":{},"headers":[],"relativePath":"core/match-patterns.md","filePath":"core/match-patterns.md"}'),t={name:"core/match-patterns.md"},c=l('<h1 id="匹配模式-match-patterns" tabindex="-1">匹配模式（<code>Match patterns</code>） <a class="header-anchor" href="#匹配模式-match-patterns" aria-label="Permalink to &quot;匹配模式（`Match patterns`）&quot;">​</a></h1><h2 id="一、匹配模式结构" tabindex="-1">一、匹配模式结构 <a class="header-anchor" href="#一、匹配模式结构" aria-label="Permalink to &quot;一、匹配模式结构&quot;">​</a></h2><p>匹配模式是采用以下结构的网址，用于指定一组网址：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scheme</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">://</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">host</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_1-scheme" tabindex="-1">1. <strong><code>scheme</code></strong> <a class="header-anchor" href="#_1-scheme" aria-label="Permalink to &quot;1. **`scheme`**&quot;">​</a></h3><p>必须是以下内容之一，并使用双斜线 (<code>//</code>) 与格式的其余部分分隔开：</p><ul><li><code>http</code></li><li><code>https</code></li><li>通配符 <code>*</code>，仅与 <code>http</code> 或 <code>https</code> 匹配</li><li><code>file</code></li></ul><h3 id="_2-host" tabindex="-1">2. <strong><code>host</code></strong> <a class="header-anchor" href="#_2-host" aria-label="Permalink to &quot;2. **`host`**&quot;">​</a></h3><p>主机名 (<code>www.example.com</code>)。</p><ul><li>主机名前的 <code>*</code>（用于匹配子网域 (<code>*.example.com</code>)），或仅使用通配符 <code>*</code>。</li><li>如果在主机模式中使用通配符，它必须是第一个或唯一字符，并且后面必须跟一个句点 (<code>.</code>) 或正斜杠 (<code>/</code>)。</li></ul><h3 id="_3-path" tabindex="-1">3. <strong><code>path</code></strong> <a class="header-anchor" href="#_3-path" aria-label="Permalink to &quot;3. **`path`**&quot;">​</a></h3><p>网址路径 (<code>/example</code>)。</p><ul><li>对于主机权限，必须提供路径，但该路径会被忽略。按照惯例，应使用通配符 (<code>/*</code>)。</li></ul><h2 id="二、特殊匹配" tabindex="-1">二、特殊匹配 <a class="header-anchor" href="#二、特殊匹配" aria-label="Permalink to &quot;二、特殊匹配&quot;">​</a></h2><h3 id="_1-all-urls" tabindex="-1">1. <code>&quot;&lt;all_urls&gt;&quot;</code> <a class="header-anchor" href="#_1-all-urls" aria-label="Permalink to &quot;1. `&quot;&lt;all_urls&gt;&quot;`&quot;">​</a></h3><ul><li>匹配以允许方案开头的所有网址，包括有效格式下列出的任何格式。由于会影响所有主机，因此在 Chrome 应用商店中审核使用它的插件可能需要更长时间。</li></ul><h3 id="_2-file" tabindex="-1">2. <code>&quot;file:///&quot;</code> <a class="header-anchor" href="#_2-file" aria-label="Permalink to &quot;2. `&quot;file:///&quot;`&quot;">​</a></h3><ul><li>允许插件在本地文件上运行。此模式要求用户手动授予访问权限。请注意，该情况需要三个斜杠，而不是两个。</li></ul><h3 id="_3-本地主机网址和-ip-地址" tabindex="-1">3. 本地主机网址和 <code>IP</code> 地址 <a class="header-anchor" href="#_3-本地主机网址和-ip-地址" aria-label="Permalink to &quot;3. 本地主机网址和 `IP` 地址&quot;">​</a></h3><ul><li>如需在开发期间匹配任何 <code>localhost</code> 端口，请使用 <code>http://localhost/*</code>。对于 <code>IP</code> 地址，请在路径中指定地址并添加通配符，例如 <code>http://127.0.0.1/*</code>。还可以使用 <code>http://*:*/*</code> 来匹配 <code>localhost、IP</code> 地址和任何端口。</li></ul><h3 id="_4-顶级网域匹配模式-top-level-domain" tabindex="-1">4. 顶级网域匹配模式（<code>Top Level domain</code>） <a class="header-anchor" href="#_4-顶级网域匹配模式-top-level-domain" aria-label="Permalink to &quot;4. 顶级网域匹配模式（`Top Level domain`）&quot;">​</a></h3><ul><li><code>Chrome</code> 不支持顶级域名 (<code>TLD</code>)的匹配格式。在各个 <code>TLD</code> 中指定匹配模式，例如 <code>http://google.es/*</code> 和 <code>http://google.fr/*</code>。</li></ul><h2 id="三、使用场景" tabindex="-1">三、使用场景 <a class="header-anchor" href="#三、使用场景" aria-label="Permalink to &quot;三、使用场景&quot;">​</a></h2><p>插件可在多种使用场景中使用匹配模式，包括：</p><ul><li>注入内容脚本</li><li>声明某些 <code>Chrome API</code> 除自身权限外还需要一些主机权限</li><li>授予对可通过 <code>Web</code> 访问的资源的访问权限。</li><li>允许使用 <code>&quot;externally_connectable.matches&quot;</code> 清单键收发消息。</li></ul><h2 id="四、示例" tabindex="-1">四、示例 <a class="header-anchor" href="#四、示例" aria-label="Permalink to &quot;四、示例&quot;">​</a></h2><ul><li><code>https://*/*</code> 或 <code>https://*/</code><ul><li>匹配使用 <code>https</code> 架构的所有网址。</li></ul></li><li><code>https://*/foo*</code><ul><li>匹配任意主机上使用 <code>https</code> 架构且路径以 <code>foo</code> 开头的任何网址。匹配示例包括 <code>https://example.com/foo/bar.html</code> 和 <code>https://www.google.com/foo</code>。</li></ul></li><li><code>https://*.google.com/foo*bar</code><ul><li>匹配 <code>google.com</code> 主机上使用 <code>https</code> 架构且路径以 <code>foo</code> 开头、以 <code>bar</code> 结尾的任何网址。匹配示例包括 <code>https://www.google.com/foo/baz/bar</code> 和 <code>https://docs.google.com/foobar</code>。</li></ul></li><li><code>file:///foo*</code><ul><li>匹配路径以 <code>foo</code> 开头的所有本地文件。匹配示例包括 <code>file:///foo/bar.html</code> 和 <code>file:///foo</code>。</li></ul></li><li><code>http://127.0.0.1/*</code> 或 <code>http://127.0.0.1/</code><ul><li>匹配主机 127.0.0.1 上使用 <code>http</code> 架构的所有网址。匹配示例包括 <code>http://127.0.0.1/</code> 和 <code>http://127.0.0.1/foo/bar.html</code>。</li></ul></li><li><code>http://localhost/*</code><ul><li>匹配任何 <code>localhost</code> 端口。</li></ul></li><li><code>*://mail.google.com/</code> 或 <code>*://mail.google.com/*</code><ul><li>匹配以 <code>http://mail.google.com</code> 或 <code>https://mail.google.com</code> 开头的所有网址。</li></ul></li></ul>',27),d=[c];function i(s,h,r,n,p,u){return a(),o("div",null,d)}const k=e(t,[["render",i]]);export{g as __pageData,k as default};
